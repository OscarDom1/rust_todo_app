use crate::models::user:: User;
use crate::utils::hashing::hash_password;
use mysql::{params, prelude::*, FromRowError, Pool, Row}; // To interact with MySQL
use serde::Deserialize;


// Structure for registration request
#[derive(Deserialize)]
pub struct RegisterRequest {
    pub name: String,
    pub email: String,
    pub password: String,
}

// Structure for login request
#[derive(Deserialize)]
pub struct LoginRequest {
    pub email: String,
    pub password: String,
}


impl mysql::prelude::FromRow for User {
    fn from_row(row: Row) -> Self {
        let (id, name, email, password): (u64, String, String, String) = mysql::from_row(row);
        User {
            id,
            name,
            email,
            password,
        }
    }

    fn from_row_opt(row: Row) -> Result<Self, FromRowError> {
        let result: Result<(u64, String, String, String), _> = mysql::from_row_opt(row);
        result.map(|(id, name, email, password)| User {
            id,
            name,
            email,
            password,
        })
    }
}

// Registration function that handles user creation
pub async fn register_user(pool: &Pool, name: &str, email: &str, password: &str) -> Result<User, String> {
    let hashed_password = hash_password(password).map_err(|_| "Failed to hash password".to_string())?;

    // Create the user and save it to the database
    let new_user = User {
        id: 0,  // ID will be assigned by the database
        name: name.to_string(),
        email: email.to_string(),
        password: hashed_password,
    };

    // Insert user into the database
    let mut conn = pool.get_conn().map_err(|_| "Failed to connect to database".to_string())?;

    // Insert user into database
    conn.exec_drop(
        "INSERT INTO users (name, email, password) VALUES (:name, :email, :password)",
        params! {
            "name" => &new_user.name,
            "email" => &new_user.email,
            "password" => &new_user.password,
        }
    ).map_err(|_| "Failed to create user in DB".to_string())?;

    // After insertion, the ID should be automatically generated by the database
    // Let's fetch the user again (with the ID) and return it
    let user: User = conn.exec_first(
        "SELECT id, name, email, password FROM users WHERE email = :email",
        params! { "email" => email }
    ).map_err(|_| "Failed to fetch user from DB".to_string())?
    .ok_or_else(|| "User not found".to_string())?;

    Ok(user)
}

// Validation function for user login
pub async fn validate_user(pool: &Pool, email: &str, password: &str) -> Result<bool, String> {
    let mut conn = pool.get_conn().map_err(|_| "Failed to connect to database".to_string())?;

    // Fetch user by email
    let user: Option<User> = conn.exec_first(
        "SELECT id, name, email, password FROM users WHERE email = :email",
        params! { "email" => email }
    ).map_err(|_| "Failed to fetch user".to_string())?;

    let user = user.ok_or_else(|| "User not found".to_string())?;

    // Validate password
    let is_valid = hash_password(password)
        .map(|hashed| hashed == user.password)
        .map_err(|_| "Failed to validate password".to_string())?;

    Ok(is_valid)
}
